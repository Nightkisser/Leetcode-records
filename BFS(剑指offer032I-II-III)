/*请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。*/
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        if (!root) return {};
        vector<vector<int>> res;
        queue<TreeNode*> que;
        que.push(root);
        while (!que.empty()) {
            res.push_back({});
            int num = que.size();
            for (int i= 0; i< num; ++i) {
                TreeNode* node= que.front();
                que.pop();
                res.back().push_back(node->val);
                if (node-> left) que.push(node->left);
                if (node-> right) que.push(node->right);
            }
        }
        int n = res.size();
        for (int i=1; i< n; i+=2){
            reverse(res[i].begin(),res[i].end());
        }
        return res;
    }
};
        // int index=1；
        // while (!que.empty()) {
        //     res.push_back({});
        //     num = que.size();
        //     stack<TreeNode*> stk;
        //     if (index%2) {
        //         queue<TreeNode*> q= que;
        //         int m = num;
        //         while(m) {
        //             stk.push(q.front());
        //             q.pop();
        //             m--;
        //         }
        //     }
        //     for (int i= 0; i< num; ++i) {
        //         if (index%2) {
        //             TreeNode* node1= stk.top();
        //             stk.pop();
        //             res.back().push_back(node1->val);
        //             // if (node-> left) que.push(node->left);
        //             // if (node-> right) que.push(node->right);
        //         }
        //         TreeNode* node= que.front();
        //         que.pop();
        //         if (index%2!=1){
        //             res.back().push_back(node->val);
        //         }
        //         if (node-> left) que.push(node->left);
        //         if (node-> right) que.push(node->right);
        //     }
        //     index++;
        // }
        // return res;
//     }
// };
